unit Unit3;

interface

uses
  Windows, Messages, SysUtils, Variants, EA_TLB, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls;

type
  TForm3 = class(TForm)
    ComboBox1: TComboBox;
    Label1: TLabel;
    SaveDialog1: TSaveDialog;
    Button1: TButton;
    Button2: TButton;
    Memo1: TMemo;
    Label2: TLabel;
    CheckBox1: TCheckBox;
    CheckBox2: TCheckBox;
    Edit1: TEdit;
    Label3: TLabel;
    procedure Button2Click(Sender: TObject);
    procedure Button1Click(Sender: TObject);
  private
    { Private declarations }
  public
    selPackage : iDualPackage;
    rep : iDualRepository;
    procedure getElementsInPackage(package : iDualPackage; var elements : tStringList);
    procedure exportXSD;
    { Public declarations }
  end;

var
  Form3: TForm3;

implementation

uses unit1;

procedure TForm3.Button1Click(Sender: TObject);
begin
  exportXSD;
end;

procedure TForm3.Button2Click(Sender: TObject);
begin
  close;
end;

procedure tForm3.getElementsInPackage(package : iDualPackage; var elements : tStringList);
var
  i : integer;
  myHolder : tNodeHolder;
  subPackage : iDualPackage;
begin
  if (package <> nil) and (package.elements.count > 0) then
  for i := 0 to package.elements.Count - 1 do
  begin
    myHolder := tNodeHolder.Create;
    myHolder.element := package.Elements.GetAt(i) as iDualElement;
    myHolder.GUID := myHolder.element.elementGUID;
    myHolder.name := myHolder.element.Name;
    myHolder.st := myHolder.element.Stereotype;
    myHolder.id := myHolder.element.ElementID;
    if (myHolder.element.type_ = 'Class') and (myHolder.st <> 'IDEAS:Individual') then elements.AddObject(myHolder.GUID,myHolder);
  end;
  if (package <> nil) and (package.Packages.count > 0) then
  for i := 0 to package.Packages.Count - 1 do
  begin
    subPackage := package.Packages.GetAt(i) as iDualPackage;
    getElementsInPackage(subPackage,elements);
  end;
end;

procedure tForm3.exportXSD;
var
  xsd, elements, supers, uniques, keyRefs, subs, keys : tStringList;
  i, j, k, index, id : integer;
  holder : tNodeHolder;
  connectors, placeable, things : iDualCollection;
  myConnector : iDualConnector;
  tt,ttt,tttt, thing, testElem, connected : iDualElement;
  name, superComma, subComma, fCat, st : string;
begin
  //has the user provided a filename ?  If so, do the export
  if savedialog1.Execute then
  begin
  //a bunch of stringlists used as lookup tables during the export
  //keys, uniques and keyrefs used to control the types of attributes
  keys := tStringList.Create;
  keys.Sorted := true;
  uniques := tStringList.Create;
  keyRefs := tStringList.Create;
  elements := tStringList.Create;
  elements.Sorted := true;
  supers := tStringList.Create;
  subs := tStringList.Create;
  //Is thing there ?
  things := rep.GetElementsByQuery('findName','Thing');
  if things.Count > 0 then
  begin
    if things.Count = 1 then thing := things.GetAt(0) as iDualElement else memo1.lines.add('THING is missing - check IDEAS Foundation is present');
  end else memo1.lines.add('THING is missing - check IDEAS Foundation is present');
  //tupletype, tupletypetype, tupletypetypetype
  tt := nil;
  ttt := nil;
  tttt := nil;
  //find all the placeable types (e.g. tt, ttt, tttt)
  placeable := rep.GetElementsByQuery('likeName','TupleType');
  if placeable.Count > 0 then
  for i := 0 to placeable.Count - 1 do
  begin
    testElem := placeable.GetAt(i) as iDualElement;
    if testElem.Name = 'TupleType' then tt := testElem;
    if testElem.Name = 'TupleTypeType' then ttt := testElem;
    if testElem.Name = 'TupleTypeTypeType' then tttt := testElem;
  end else memo1.lines.add('The Tuple powertype levels are missing - check IDEAS Foundation is present');

  if tt = nil then memo1.lines.add('TupleType not found - check IDEAS Foundation is present');
  if ttt = nil then memo1.lines.add('TupleTypeType not found - check IDEAS Foundation is present');
  if tttt = nil then memo1.lines.add('TupleTypeTypeType not found - check IDEAS Foundation is present');

  //that's right...we're not using DOM or SAX...just plain old text !
  xsd := tStringList.Create;

  //xsd boiler plate
  xsd.Add('<?xml version="1.0" encoding="UTF-8"?>');
  xsd.Add('<!-- Auto-Generated by Model Futures IDEAS Add-In for Sparx EA -->');
  xsd.Add('<!-- XML Schema format designed by Model Futures Ltd and Silver Bullet inc. on behalf of UK MOD and US DoD -->');
  xsd.Add('<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:dm2="http://www.ideasgroup.org/dm2" xmlns:ism="urn:us:gov:ic:ism:v2" elementFormDefault="qualified" attributeFormDefault="unqualified" xmlns:ideas="http://www.ideasgroup.org/xsd">');
  //have they selected the IC-ISM option ?
  if checkbox1.Checked then xsd.Add('	<xs:import namespace="urn:us:gov:ic:ism:v2" schemaLocation="IC-ISM-v2.1.xsd"/>');
  if checkbox2.Checked then xsd.Add('	<xs:import namespace="http://www.ideasgroup.org/dm2" schemaLocation="dm2Foundation.xsd"/>');
  xsd.Add('	<xs:import namespace="http://www.ideasgroup.org/xsd" schemaLocation="IdeasFoundation.xsd"/>');
  xsd.Add('	<xs:element name="IdeasEnvelope">');
  xsd.Add('		<xs:annotation>');
  xsd.Add('			<xs:documentation>The root element of an IDEAS data exchange file</xs:documentation>');
  xsd.Add('		</xs:annotation>');
  xsd.Add('		<xs:complexType>');
  xsd.Add('			<xs:sequence>');
  xsd.Add('				<xs:any namespace="http://purl.org/dc/elements/1.1/" processContents="skip" minOccurs="0" maxOccurs="unbounded"/>');
  xsd.Add('				<xs:element name="IdeasData" minOccurs="0" maxOccurs="unbounded">');
  xsd.Add('					<xs:complexType>');
  xsd.Add('						<xs:sequence maxOccurs="unbounded">');
  xsd.Add('							<xs:choice>');
  xsd.Add('								<xs:element name="NamingScheme" maxOccurs="unbounded">');
  xsd.Add('									<xs:complexType>');
  xsd.Add('										<xs:complexContent>');
  xsd.Add('											<xs:extension base="ideas:NamingScheme">');
  //IC-ISM
  if checkbox1.Checked then xsd.Add('												<xs:attributeGroup ref="ism:SecurityAttributesOptionGroup"/>');
  xsd.Add('											</xs:extension>');
  xsd.Add('										</xs:complexContent>');
  xsd.Add('									</xs:complexType>');
  xsd.Add('								</xs:element>');
 //uniques is a stringlist appended to the xsd stringlist at the end
    uniques.Add('		<xs:key name="NamingSchemeUnique">');
    uniques.Add('			<xs:selector xpath=".//NamingScheme"/>');
    uniques.Add('			<xs:field xpath="@id"/>');
    uniques.Add('		</xs:key>');

  xsd.Add('								<!-- This section is generated from the model according to the IDEAS XSD production rules -->');

  //get all the elements in the exported package, and step through them
  getElementsInPackage(selPackage,elements);
  if elements.Count > 0 then
  for i := 0 to elements.Count - 1 do
  begin
    holder := elements.Objects[i] as tNodeHolder;
    name := holder.element.Name;
    if name = '' then
    begin
      memo1.Lines.Add('No Name for: ' + holder.GUID);
      name := holder.GUID;
    end;
    if pos(' ',name) > 0 then
    begin
      memo1.Lines.Add('Spaces found in: ' + name);
      name := stringReplace(name,' ','_',[rfReplaceAll]);
    end;
    if pos(':',name) > 0 then
    begin
      memo1.Lines.Add('Colon found in: ' + name);
      name := stringReplace(name,':','_',[rfReplaceAll]);
    end;

    //add XSD code for the element

    xsd.Add('							  <xs:element name="' + name + '" maxOccurs="unbounded">');
    if holder.element.Notes <> '' then
    begin
      xsd.Add('	              	<xs:annotation>');
      xsd.Add('		              	<xs:documentation>'  + holder.element.Notes + '</xs:documentation>');
      xsd.Add('	               	</xs:annotation>');
    end else memo1.Lines.Add('No description for ' + name);
    xsd.Add('									<xs:complexType>');
    xsd.Add('										<xs:complexContent>');

    //get all its supertypes

    superComma := holder.element.GetRelationSet(rsGeneralizeStart);
    fcat := 'ideas:Thing';
    if superComma <> '' then
    begin
      supers.Clear;
      supers.Sorted := false;
      supers.CommaText := superComma;
      for j := 0 to supers.Count - 1 do
      begin
        val(supers[j],id,index);
        testElem := rep.GetElementByID(id);
        supers[j] := testElem.Name;
      end;
      supers.Add(holder.element.name);
      supers.Sorted := true;
      //test the supertypes to ascertain the foundation category
      if not supers.Find('Thing',index) then memo1.Lines.Add(name + ' does not descend from Thing');
      if supers.Find('Individual',index) then fCat := 'ideas:Individual';
      if supers.Find('Type',index) then fCat := 'ideas:Type';
      if supers.Find('Powertype',index) then fCat := 'ideas:Powertype';
      if supers.Find('TupleType',index) then fCat := 'ideas:TupleType';
      if supers.Find('CoupleType',index) then fCat := 'ideas:CoupleType';
      if supers.Find('WholePartType',index) then fCat := 'ideas:WholePartType';
      if supers.Find('TripleType',index) then fCat := 'ideas:TripleType';
      if supers.Find('QuadrupleType',index) then fCat := 'ideas:QuadrupleType';
      if supers.Find('QuintupleType',index) then fCat := 'ideas:QuintupleType';
      if supers.Find('TupleTypeType',index) then fCat := 'ideas:TupleTypeType';
      if supers.Find('TupleTypeTypeType',index) then fCat := 'ideas:TupleTypeTypeType';
      if supers.Find('IndividualType',index) then fCat := 'ideas:IndividualType';
      if supers.Find('IndividualTypeType',index) then fCat := 'ideas:IndividualTypeType';
      if supers.Find('IndividualTypeTypeType',index) then fCat := 'ideas:IndividualTypeTypeType';
      if supers.Find('tuple',index) then fCat := 'ideas:tuple';
      if supers.Find('couple',index) then fCat := 'ideas:couple';
      if supers.Find('triple',index) then fCat := 'ideas:triple';
      if supers.Find('quadruple',index) then fCat := 'ideas:quadruple';
      if supers.Find('quintuple',index) then fCat := 'ideas:quintuple';
      if supers.Find('wholePart',index) then fCat := 'ideas:wholePart';
      if supers.Find('superSubtype',index) then fCat := 'ideas:superSubtype';
      if supers.Find('namedBy',index) then fCat := 'ideas:nameBy';
      if supers.Find('typeInstance',index) then fCat := 'ideas:typeInstance';
      if supers.Find('powertypeInstance',index) then fCat := 'ideas:powertypeInstance';
   //   if supers.Find('Name',index) then fCat := 'Name';
      if supers.Find('NamingScheme',index) then fCat := 'ideas:NamingScheme';

      //if its a tuple, a tupletype, etc., need to handle its places
      if supers.Find('tuple',index) or supers.Find('TupleType',index) or supers.Find('TupleTypeType',index) or supers.Find('TupleTypeTypeType',index) then
      begin
        // get everything connected to the element
        connectors := holder.element.Connectors;
        if connectors.count > 0 then
        for j := 0 to connectors.Count - 1 do
        begin
          myConnector := connectors.GetAt(j) as iDualConnector;
          if (myConnector.ClientID = holder.element.ElementID) then
          begin
            connected := rep.GetElementByID(myConnector.SupplierID);
            if elements.Find(connected.ElementGUID,index) then
            begin
              //get the subtypes of the connected element - this is so we can properly constrain the relationship in the unique key clauses
              subComma := connected.GetRelationSet(rsGeneralizeEnd);
              subs.Clear;
              subs.Sorted := false;
              subs.CommaText := subComma;
              for k := 0 to subs.Count - 1 do
              begin
                val(subs[k],id,index);
                testElem := rep.GetElementByID(id);
                if elements.Find(testElem.ElementGUID,index) then subs[k] := testElem.Name else subs[k] := '';;
              end;
              subs.Add(connected.Name);
              subs.Sorted := true;
              while subs[0] = '' do subs.Delete(0);
              //set text to match the xPath notation (replace commas with .//)
              subComma := stringReplace(subs.CommaText,',',' | .//',[rfReplaceAll]);
              st := myConnector.Stereotype;
              //if there are subtypes, create the constraint
              if subs.count > 0 then
              begin
                if not keys.Find(connected.ElementGUID,index) then
                begin
                  uniques.Add('		<xs:key name="' + connected.name + 'Unique">');
                  uniques.Add('			<xs:selector xpath=".//' + subComma + '"/>');
                  uniques.Add('			<xs:field xpath="@id"/>');
                  uniques.Add('		</xs:key>');
                  keys.Add(connected.ElementGUID);
                end;
              end;

              //further refine the foundation category
              if (st = 'place2Type') and (fcat = 'ideas:TupleType') then fcat := 'ideas:CoupleType';
              if (st = 'place3Type') and ((fcat = 'ideas:TupleType') or (fcat = 'ideas:CoupleType')) then fcat := 'ideas:TripleType';
              if (st = 'tuplePlace2') and (fcat = 'ideas:tuple') then fcat := 'ideas:couple';
              if (st = 'tuplePlace3') and ((fcat = 'ideas:tuple') or (fcat = 'ideas:couple')) then fcat := 'ideas:triple';

              //is it a placeType or place ?
              if (pos('lace',st) > 0) then
              begin
                //form the constraint
                keyRefs.Add('		<xs:keyref name="' + name + myConnector.Stereotype +'" refer="' + connected.name + 'Unique">');
                keyRefs.Add('			<xs:selector xpath=".//' + name + '"/>');
                if supers.Find('tuple',index) then
                begin
                  st := stringReplace(st,'Type','',[rfReplaceAll]);
                  st := 'tuple' + stringReplace(st,'p','P',[rfReplaceAll]);
                end;
                keyRefs.Add('			<xs:field xpath="@' + st +'"/>');
                keyRefs.Add('		</xs:keyref>');
              end else memo1.lines.add('Unrecognised stereotype: ' + st);
            end;
          end;
        end;
      end;

    end else memo1.Lines.Add(name + ' is not a subtype of anything');

    xsd.Add('											<xs:extension base="' + fCat + '">');
    //add DM2 pedigree stuff if required
    if checkbox2.Checked then xsd.Add('												<xs:sequence>');
    if checkbox2.Checked then xsd.Add('													<xs:element ref="dm2:InformationPedigree" minOccurs="0" maxOccurs="1"/>');
    if checkbox2.Checked then xsd.Add('												</xs:sequence>');
    if checkbox2.Checked then xsd.Add('												<xs:attributeGroup ref="ism:SecurityAttributesOptionGroup"/>');
    xsd.Add('											</xs:extension>');
    xsd.Add('										</xs:complexContent>');
    xsd.Add('									</xs:complexType>');
    xsd.Add('								</xs:element>');
  end;
  //closing XSD boiler plate
  xsd.Add('							</xs:choice>     ');
  xsd.Add('						</xs:sequence>   ');
  xsd.Add('						<xs:attribute name="XMLTagsBoundToNamingScheme" type="xs:string" use="required" fixed="' + ComboBox1.text + '"/>');
  xsd.Add('						<xs:attribute name="Model" type="xs:string" use="required"/> ');
  xsd.Add('					</xs:complexType> ');
  xsd.Add('				</xs:element>  ');
  xsd.Add('				<xs:element name="IdeasViews" minOccurs="0">  ');
  xsd.Add('					<xs:complexType>  ');
  xsd.Add('						<xs:attribute name="Framework" type="xs:string" use="required"/>  ');
  xsd.Add('						<xs:attribute name="Model" type="xs:string" use="required"/> ');
  xsd.Add('					</xs:complexType>  ');
  xsd.Add('				</xs:element>  ');
  xsd.Add('			</xs:sequence> ');
	if checkbox1.Checked then xsd.Add('		<xs:attributeGroup ref="ism:SecurityAttributesGroup"/>');
  xsd.Add('			<xs:attribute name="OriginatingNationISO3166TwoLetterCode" type="xs:string" use="required"/>  ');
  xsd.Add('		</xs:complexType>   ');

  xsd.Add('		<xs:key name="namesUnique">');
  xsd.Add('			<xs:selector xpath=".//*/ideas:Name"/>');
  xsd.Add('			<xs:field xpath="@id"/>');
  xsd.Add('		</xs:key>');

  xsd.AddStrings(uniques);
  xsd.AddStrings(keyRefs);


  xsd.Add('	</xs:element>  ');
  xsd.Add('</xs:schema> ');
  xsd.SaveToFile(savedialog1.FileName);
  end;
end;

{$R *.dfm}

end.
