unit Unit3;

interface

uses
  Windows, Messages, SysUtils, EA_Ideas_Lib, Variants, EA_TLB, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, ComCtrls;

type
  TForm3 = class(TForm)
    ComboBox1: TComboBox;
    Label1: TLabel;
    SaveDialog1: TSaveDialog;
    Button1: TButton;
    Button2: TButton;
    Memo1: TMemo;
    CheckBox1: TCheckBox;
    CheckBox2: TCheckBox;
    Edit1: TEdit;
    Label3: TLabel;
    ProgressBar1: TProgressBar;
    CheckBox3: TCheckBox;
    CheckBox4: TCheckBox;
    CheckBox5: TCheckBox;
    procedure Button2Click(Sender: TObject);
    procedure Button1Click(Sender: TObject);
    function createElementRef(elenName, diagName, indent, minOccurs : string) : tStringList;
    procedure FormShow(Sender: TObject);
  private
    { Private declarations }
  public
    selPackage : iDualPackage;
    rep : iDualRepository;
    keyRefs : tStringList;
    procedure exportXSD;
    { Public declarations }
  end;

var
  Form3: TForm3;

implementation

uses unit1;

procedure TForm3.Button1Click(Sender: TObject);
begin
  exportXSD;
end;

procedure TForm3.Button2Click(Sender: TObject);
begin
  close;
end;



procedure tForm3.exportXSD;
var
  xsd, elements, supers, uniques, subs, keys, mandatory, optional : tStringList;
  errors : tStrings;
  i, j, k, index, id : integer;
  holder : tElemHolder;
  connectors, placeable, things, diagrams : iDualCollection;
  myConnector : iDualConnector;
  tt,ttt,tttt, thing, testElem, connected, immediateSupertype, tempElem : iDualElement;
  superComma, subComma, fCat, st : string;
  myDiag : iDualDiagram;
  myDo : iDualDiagramObject;
  styleStr : string;
  nsFound : boolean;
begin
  errors := tStringList.Create;
  nsFOund := false; //set to true if NamingScheme is found in package being exported
  button2.Enabled := false;
  //has the user provided a filename ?  If so, do the export
  if savedialog1.Execute then
  begin
  //a bunch of stringlists used as lookup tables during the export
  //keys, uniques and keyrefs used to control the types of attributes
  keys := tStringList.Create;
  keys.Sorted := true;
  uniques := tStringList.Create;
  keyRefs := tStringList.Create;
  elements := tStringList.Create;
  elements.Sorted := true;
  supers := tStringList.Create;
  subs := tStringList.Create;
  mandatory := tStringList.Create;
  errors := memo1.Lines;

  doInitialChecks(rep,selPackage,errors);

  //that's right...we're not using DOM or SAX...just plain old text !
  xsd := tStringList.Create;

  //xsd boiler plate
  xsd.Add('<?xml version="1.0" encoding="UTF-8"?>');
  xsd.Add('<!-- Auto-Generated by Model Futures IDEAS Add-In for Sparx EA - download from http://www.modelfutures.com/software/ -->');
  xsd.Add('<!-- XML Schema format designed by Model Futures Ltd and Silver Bullet inc. on behalf of US DoD -->');
  xsd.Add('<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:dm2="http://www.ideasgroup.org/dm2" xmlns:ism="urn:us:gov:ic:ism:v2" ');
  xsd.Add('  elementFormDefault="qualified" attributeFormDefault="unqualified" xmlns:ideas="http://www.ideasgroup.org/xsd" xmlns:dc="http://purl.org/dc/elements/1.1/" >');
  //have they selected the IC-ISM option ?
  if checkbox1.Checked then xsd.Add('	<xs:import namespace="urn:us:gov:ic:ism:v2" schemaLocation="IC-ISM-v2.1.xsd"/>');
  if checkbox2.Checked then xsd.Add('	<xs:import namespace="http://www.ideasgroup.org/dm2" schemaLocation="dm2Foundation.xsd"/>');
  xsd.Add('	<xs:import namespace="http://www.ideasgroup.org/xsd" schemaLocation="IdeasFoundation.xsd"/>');
//  xsd.Add('	<xs:import namespace="http://www.ideasgroup.org/xsd/TopLevel" schemaLocation="IdeasTopLevel.xsd"/>');
  xsd.Add('	<xs:element name="IdeasEnvelope">');
  xsd.Add('		<xs:annotation>');
  xsd.Add('			<xs:documentation>The root element of an IDEAS data exchange file</xs:documentation>');
  xsd.Add('		</xs:annotation>');
  xsd.Add('		<xs:complexType>');
  xsd.Add('			<xs:sequence>');
  xsd.Add('				<xs:any namespace="http://purl.org/dc/elements/1.1/" processContents="skip" minOccurs="0" maxOccurs="unbounded"/>');
  xsd.Add('				<xs:element name="IdeasData" minOccurs="0" maxOccurs="unbounded">');
  xsd.Add('					<xs:complexType>');
  xsd.Add('						<xs:sequence maxOccurs="unbounded">');
  xsd.Add('							<xs:choice>');

  xsd.Add('								<!-- This section is generated from the model according to the IDEAS XSD production rules -->');

  //get all the elements in the exported package, and step through them
  getElementsInPackage(selPackage,elements,'',rep,checkbox5.Checked, errors, self);
  progressbar1.Max := elements.Count;
  if elements.Count > 0 then
  for i := 0 to elements.Count - 1 do
  begin
    progressbar1.Position := i;
    holder := elements.Objects[i] as tElemHolder;
//    if not holder.element.Abstract then
//    begin

    checkElem(rep,holder,errors,true, false);

    //add XSD code for the element

 //   if holder.element.Multiplicity = '1..*' then xsd.Add('							  <xs:element name="' + name + '" minOccurs="1" maxOccurs="unbounded">')
 //                                           else xsd.Add('							  <xs:element name="' + name + '" minOccurs="0" maxOccurs="unbounded">');
    xsd.Add('							  <xs:element name="' + holder.name + '">');
    uniques.Add('		<xs:key name="' + holder.name + 'Key">');
    uniques.Add('			<xs:selector xpath=".//' + holder.name + '"/>');
    uniques.Add('			<xs:field xpath="@id"/>');
    uniques.Add('		</xs:key>');
    if holder.element.Notes <> '' then
    begin
      xsd.Add('	              	<xs:annotation>');
      xsd.Add('		              	<xs:documentation>'  + holder.element.Notes + '</xs:documentation>');
      xsd.Add('	               	</xs:annotation>');
    end;
    xsd.Add('									<xs:complexType>');
    xsd.Add('										<xs:complexContent>');

    //get all its supertypes
    fcat := getFoundationCategory(rep,holder.element,superComma,supers, errors);

  //  superComma := holder.element.GetRelationSet(rsGeneralizeStart);
//    fcat := 'ideas:Thing';
    if superComma <> '' then
    begin
    {  supers.Clear;
      supers.Sorted := false;
      supers.CommaText := superComma;
      for j := 0 to supers.Count - 1 do
      begin
        val(supers[j],id,index);
        testElem := rep.GetElementByID(id);
        supers[j] := testElem.Name;
      end;
      supers.Add(holder.element.name);
      supers.Sorted := true;
      //test the supertypes to ascertain the foundation category
      if supers.Find('Individual',index) then fCat := 'ideas:Individual';
      if supers.Find('Type',index) then fCat := 'ideas:Type';
      if supers.Find('Powertype',index) then fCat := 'ideas:Powertype';
      if supers.Find('TupleType',index) then fCat := 'ideas:TupleType';
      if supers.Find('CoupleType',index) then fCat := 'ideas:CoupleType';
      if supers.Find('WholePartType',index) then fCat := 'ideas:WholePartType';
      if supers.Find('TripleType',index) then fCat := 'ideas:TripleType';
      if supers.Find('QuadrupleType',index) then fCat := 'ideas:QuadrupleType';
      if supers.Find('QuintupleType',index) then fCat := 'ideas:QuintupleType';
      if supers.Find('TupleTypeType',index) then fCat := 'ideas:TupleTypeType';
      if supers.Find('TupleTypeTypeType',index) then fCat := 'ideas:TupleTypeTypeType';
      if supers.Find('IndividualType',index) then fCat := 'ideas:IndividualType';
      if supers.Find('IndividualTypeType',index) then fCat := 'ideas:IndividualTypeType';
      if supers.Find('IndividualTypeTypeType',index) then fCat := 'ideas:IndividualTypeTypeType';
      if supers.Find('tuple',index) then fCat := 'ideas:tuple';
      if supers.Find('couple',index) then fCat := 'ideas:couple';
      if supers.Find('triple',index) then fCat := 'ideas:triple';
      if supers.Find('quadruple',index) then fCat := 'ideas:quadruple';
      if supers.Find('quintuple',index) then fCat := 'ideas:quintuple';
      if supers.Find('wholePart',index) then fCat := 'ideas:wholePart';
      if supers.Find('superSubtype',index) then fCat := 'ideas:superSubtype';
      if supers.Find('representedBy',index) then fCat := 'ideas:representedBy';
      if supers.Find('describedBy',index) then fCat := 'ideas:describedBy';
      if supers.Find('namedBy',index) then fCat := 'ideas:namedBy';
      if supers.Find('typeInstance',index) then fCat := 'ideas:typeInstance';
      if supers.Find('powertypeInstance',index) then fCat := 'ideas:powertypeInstance';
      if supers.Find('Name',index) then fCat := 'Name';
      if supers.Find('NamingScheme',index) then fCat := 'ideas:NamingScheme';
      if supers.Find('UniqueNamingScheme',index) then fCat := 'ideas:UniqueNamingScheme';
      if fcat = 'ideas:Thing' then errors.Add('WARNING: Foundation category for ' + holder.element.Name + ' may be unknown');
   //   if holder.element.Stereotype = 'IDEAS:UniqueNamingScheme' or  then

      }
      immediateSupertype := nil;
      // get everything connected to the element
      connectors := holder.element.Connectors;
      if connectors.count > 0 then
      for j := 0 to connectors.Count - 1 do
      begin
        myConnector := connectors.GetAt(j) as iDualConnector;
        checkConnector(rep,holder,myConnector,errors);
        if (myConnector.ClientID = holder.element.ElementID) then
        begin
          connected := rep.GetElementByID(myConnector.SupplierID);
          if (myConnector.Direction = 'Destination -> Source') then
          begin
            errors.Add('ERROR: ' + myconnector.Stereotype + ' connector from ' + connected.Name + ' to ' + myConnector.Name + ' has reversed direction.');
            myConnector.SupplierID := holder.element.ElementID;
            myConnector.clientID := connected.ElementID;
            myConnector.Direction := 'Source -> Destination';
            myConnector.Update;
            errors.Add(' -Direction has been fixed to Source->Destination, but you''ll have to run this export again');
          end;
          if myConnector.Direction <> 'Source -> Destination' then errors.Add('WARNING: ' + myconnector.Stereotype + ' connector from ' + connected.Name + ' to ' + myConnector.Name + ' has no direction.');

          if elements.Find(connected.ElementGUID,index) then
          begin
            //first of all, is this a generalisation ?
            if myConnector.type_ = 'Generalization' then
            begin
        //      memo1.Lines.Add(holder.name + ' inherits from ' + connected.name);
              if immediateSupertype = nil then immediateSupertype := connected else errors.Add('WARNING: ' + holder.name + ' multiply inherits');
            end;
            //if its a tuple, a tupletype, etc., need to handle its places
            if supers.Find('tuple',index) or supers.Find('TupleType',index) or supers.Find('TupleTypeType',index) or supers.Find('TupleTypeTypeType',index) then
            begin
              //get the subtypes of the connected element - this is so we can properly constrain the relationship in the unique key clauses
              subComma := connected.GetRelationSet(rsGeneralizeEnd);
              subs.Clear;
              subs.Sorted := false;
              subs.CommaText := subComma;
              for k := 0 to subs.Count - 1 do
              begin
                val(subs[k],id,index);
                testElem := rep.GetElementByID(id);
                if elements.Find(testElem.ElementGUID,index) then subs[k] := testElem.Name else subs[k] := '';;
              end;
              subs.Add(connected.Name);
              subs.Sorted := true;
              while subs[0] = '' do subs.Delete(0);
              //set text to match the xPath notation (replace commas with .//)
              subComma := stringReplace(subs.CommaText,',',' | .//',[rfReplaceAll]);
              st := myConnector.Stereotype;
              //if there are subtypes, create the constraint
              if subs.count > 0 then
              begin
                if not keys.Find(connected.ElementGUID,index) then
                begin
                  uniques.Add('		<xs:key name="' + connected.name + 'Unique">');
                  uniques.Add('			<xs:selector xpath=".//' + subComma + '"/>');
                  uniques.Add('			<xs:field xpath="@id"/>');
                  uniques.Add('		</xs:key>');
                  keys.Add(connected.ElementGUID);
                end;
              end;

              //further refine the foundation category
              if (st = 'place2Type') and (fcat = 'ideas:TupleType') then fcat := 'ideas:CoupleType';
              if (st = 'place3Type') and ((fcat = 'ideas:TupleType') or (fcat = 'ideas:CoupleType')) then fcat := 'ideas:TripleType';
              if (st = 'tuplePlace2') and (fcat = 'ideas:tuple') then fcat := 'ideas:couple';
              if (st = 'tuplePlace3') and ((fcat = 'ideas:tuple') or (fcat = 'ideas:couple')) then fcat := 'ideas:triple';

              //is it a placeType or place ?
              if (pos('lace',st) > 0) then
              begin
                //form the constraint
                keyRefs.Add('		<xs:keyref name="' + holder.element.name + myConnector.Stereotype +'" refer="' + connected.name + 'Unique">');
                keyRefs.Add('			<xs:selector xpath=".//' + name + '"/>');
                if supers.Find('tuple',index) then
                begin
                  st := stringReplace(st,'Type','',[rfReplaceAll]);
                  st := 'tuple' + stringReplace(st,'p','P',[rfReplaceAll]);
                end;
                keyRefs.Add('			<xs:field xpath="@' + st +'"/>');
                keyRefs.Add('		</xs:keyref>');
              end;
            end;
          end;
        end;
      end;

    end else errors.Add('ERROR: ' + name + ' is not a subtype of anything');

    if immediateSupertype <> nil then xsd.Add('											<!-- Subtype of ' + immediateSupertype.Name + ' -->');
    xsd.Add('											<xs:extension base="' + fCat + '">');


    //add DM2 pedigree stuff if required
    if checkbox2.Checked then xsd.Add('												<xs:sequence>');
    if checkbox2.Checked then xsd.Add('													<xs:element ref="dm2:InformationPedigree" minOccurs="0" maxOccurs="1"/>');
    if checkbox2.Checked then xsd.Add('												</xs:sequence>');
    if checkbox2.Checked then xsd.Add('												<xs:attributeGroup ref="ism:SecurityAttributesOptionGroup"/>');
    xsd.Add('											</xs:extension>');
    xsd.Add('										</xs:complexContent>');
    xsd.Add('									</xs:complexType>');
    xsd.Add('								</xs:element>');
  end;
  if not nsFound then
  begin
    xsd.Add('								<xs:element name="NamingScheme" maxOccurs="unbounded">');
    xsd.Add('									<xs:complexType>');
    xsd.Add('										<xs:complexContent>');
    xsd.Add('											<xs:extension base="ideas:NamingScheme">');
    //IC-ISM
    if checkbox1.Checked then xsd.Add('												<xs:attributeGroup ref="ism:SecurityAttributesOptionGroup"/>');
    xsd.Add('											</xs:extension>');
    xsd.Add('										</xs:complexContent>');
    xsd.Add('									</xs:complexType>');
    xsd.Add('								</xs:element>');
    xsd.Add('								<xs:element name="UniqueNamingScheme" maxOccurs="unbounded">');
    xsd.Add('									<xs:complexType>');
    xsd.Add('										<xs:complexContent>');
    xsd.Add('											<xs:extension base="ideas:UniquwNamingScheme">');
    //IC-ISM
    if checkbox1.Checked then xsd.Add('												<xs:attributeGroup ref="ism:SecurityAttributesOptionGroup"/>');
    xsd.Add('											</xs:extension>');
    xsd.Add('										</xs:complexContent>');
    xsd.Add('									</xs:complexType>');
    xsd.Add('								</xs:element>');
    //uniques is a stringlist appended to the xsd stringlist at the end
    uniques.Add('		<xs:key name="NamingSchemeUnique">');
    uniques.Add('			<xs:selector xpath=".//NamingScheme"/>');
    uniques.Add('			<xs:field xpath="@id"/>');
    uniques.Add('		</xs:key>');
    uniques.Add('		<xs:key name="UniqueNamingSchemeUnique">');
    uniques.Add('			<xs:selector xpath=".//UniqueNamingScheme"/>');
    uniques.Add('			<xs:field xpath="@id"/>');
    uniques.Add('		</xs:key>');
  end;
  //closing XSD boiler plate stuff
  xsd.Add('							</xs:choice>     ');
  xsd.Add('						</xs:sequence>   ');
  xsd.Add('						<xs:attribute name="XMLTagsBoundToNamingScheme" type="xs:string" use="required" fixed="' + ComboBox1.text + '"/>');
  xsd.Add('				  	<!-- ontology Attribute must be used to specify the underlying model used - e.g. DM2, M3 --> ');
  xsd.Add('						<xs:attribute name="ontology" type="xs:string" use="required"/> ');
  xsd.Add('				  	<!-- ontologyVersion must be used to specify the revision number of the model used - e.g. 1.02 --> ');
  xsd.Add('						<xs:attribute name="ontologyVersion" type="xs:string" use="required"/> ');
  xsd.Add('						<xs:attribute name="defaultNamingScheme" type="xs:IDREF" use="optional"/>');
  xsd.Add('					</xs:complexType> ');
  xsd.Add('				</xs:element>  ');  //End of IdeasData
  //now check to see if there are any diagrams...and if so, export each one as a view
  xsd.Add('				<xs:element name="IdeasViews" minOccurs="0">  ');
  xsd.Add('					<xs:complexType>  ');
  xsd.Add('				  	<xs:sequence maxOccurs="unbounded"> ');
  xsd.Add('					  	<xs:choice>   ');
  diagrams := selPackage.Diagrams;
  memo1.Lines.Add('Found ' + vartostr(diagrams.Count) + ' diagram(s)');
  if (diagrams.count > 0) and checkbox4.checked then
  for i := 0 to diagrams.Count - 1 do
  begin
    myDiag := diagrams.GetAt(i) as iDualDiagram;
    if myDiag.Stereotype = 'VIEW' then
    begin
      memo1.Lines.Add('-diagram: ' + myDiag.name + ' with ' + vartostr(myDiag.DiagramObjects.count) + ' element(s)');
      xsd.Add('					  	  <xs:element name="' + myDiag.name + '">  ');
      xsd.Add('				        	<xs:complexType>  ');
      xsd.Add('				  	        <xs:sequence minOccurs="1" maxOccurs="1"> ');
      xsd.Add('				  	          <!-- Dublin Core meta-data tags are used to capture diagram creator, date, etc. --> ');
      xsd.Add('				  	          <xs:any namespace="http://purl.org/dc/elements/1.1/" processContents="skip" minOccurs="0" maxOccurs="unbounded"/>');
      if mandatory <> nil then freeandnil(mandatory);
      mandatory := tStringlist.Create;
      mandatory.Sorted := true;
      if optional <> nil then freeandnil(optional);
      optional := tStringlist.Create;
      optional.Sorted := true;
      progressbar1.Max := myDiag.DiagramObjects.count;
      if myDiag.DiagramObjects.count > 0 then
      for j := 0 to myDiag.DiagramObjects.Count - 1 do
      begin
        progressbar1.Position := j;
        myDO := myDiag.DiagramObjects.GetAt(j) as iDualDiagramObject;
        thing := rep.GetElementByID(myDO.ElementID);
        if (elements.Find(thing.ElementGUID,index)) and (pos('IDEAS:',vartostr(thing.Stereotype)) = 1) then
        begin
          //look for elements that have red outline - they are mandatory elements !
          styleStr := vartostr(myDo.Style);
          if pos('LCol=255;',styleStr) > 0 then mandatory.Add(thing.name) else optional.Add(thing.name);
        end else memo1.Lines.Add(thing.Name + ' packageID=' + vartostr(thing.PackageID) + '  Package ID=' + vartostr(selPackage.PackageID));
      end;
      if mandatory.Count > 0 then
      begin
        xsd.Add('				     	        <xs:element name="MandatoryElements" minOccurs="1" maxOccurs="1"> ');
        xsd.Add('				              	<xs:complexType>  ');
        xsd.Add('				                	<xs:sequence maxOccurs="unbounded"> ');
        for j := 0 to mandatory.Count - 1 do
        begin
          xsd.AddStrings(createElementRef(mandatory[j],myDiag.Name,'				                	  ','1'));
        end;
        xsd.Add('				                	</xs:sequence> ');
        xsd.Add('				              	</xs:complexType>  ');
        xsd.Add('				     	        </xs:element> ');
      end;
      if optional.Count > 0 then
      begin
        xsd.Add('				     	        <xs:element name="OptionalElements" minOccurs="1" maxOccurs="1"> ');
        xsd.Add('				              	<xs:complexType>  ');
        xsd.Add('				                	<xs:sequence maxOccurs="unbounded"> ');
        xsd.Add('				                	  <xs:choice> ');
        for j := 0 to optional.Count - 1 do
        begin
          xsd.AddStrings(createElementRef(optional[j],myDiag.Name,'		  		                	  ','0'));
        end;
        xsd.Add('				                	  </xs:choice> ');
        xsd.Add('				                	</xs:sequence> ');
        xsd.Add('				              	</xs:complexType>  ');
        xsd.Add('				     	        </xs:element> ');
      end;

      xsd.Add('				  	        </xs:sequence>');
      xsd.Add('				  	        <xs:attributeGroup ref="DiagAttributes"/>');
      if checkbox1.Checked then  xsd.Add('				  	        <!-- Security information may be applied to an entire diagram - e.g. in case of aggregation of classification --> ');
      if checkbox1.Checked then xsd.Add('				  	        <xs:attributeGroup ref="ism:SecurityAttributesOptionGroup"/>');
      xsd.Add('				        	</xs:complexType>  ');
      xsd.Add('					  	  </xs:element>  ');
    end;
  end;
  xsd.Add('					  	</xs:choice>  ');
  xsd.Add('					  </xs:sequence>  ');
  xsd.Add('				  	<!-- Framework attribute must be used to specify the underlying framework used - e.g. DoDAF, MODAF --> ');
  xsd.Add('						<xs:attribute name="framework" type="xs:string" use="required"/>  ');
  xsd.Add('				  	<!-- frameworkVersion Attribute must be used to specify the revision number of the framework used - e.g. 1.02 --> ');
  xsd.Add('						<xs:attribute name="frameworkVersion" type="xs:string" use="required"/> ');
  xsd.Add('					</xs:complexType>  ');
  xsd.Add('				</xs:element>  ');
  xsd.Add('			</xs:sequence> ');
	if checkbox1.Checked then xsd.Add('		<xs:attributeGroup ref="ism:SecurityAttributesGroup"/>');
  xsd.Add('			<xs:attribute name="OriginatingNationISO3166TwoLetterCode" type="xs:string" use="required"/>  ');
  xsd.Add('		</xs:complexType>   ');

  xsd.Add('		<xs:key name="namesUnique">');
  xsd.Add('			<xs:selector xpath=".//*/ideas:Name"/>');
  xsd.Add('			<xs:field xpath="@id"/>');
  xsd.Add('		</xs:key>');

  xsd.AddStrings(uniques);
  xsd.AddStrings(keyRefs);


  xsd.Add('	</xs:element>  ');
  xsd.Add(' <xs:attributeGroup name="DiagAttributes">');
  xsd.Add('		<xs:attribute name="name" type="xs:string" use="required"/>  ');
  xsd.Add('		<!-- a diagram ID may be optionally provided -->');
  xsd.Add('		<xs:attribute name="id" type="xs:ID"/>  ');
  xsd.Add('		<!-- width and height of diagram may be optionally specified -->');
  xsd.Add('		<xs:attribute name="width" type="xs:integer"/>  ');
  xsd.Add('		<xs:attribute name="height" type="xs:integer"/> ');
  xsd.Add(' </xs:attributeGroup>');
  xsd.Add(' <xs:attributeGroup name="DiagElementAttributes">');
  xsd.Add('	  <!-- ref is a reference to the thing displayed in the diagram -->');
  xsd.Add('	  <xs:attribute name="ref" type="xs:IDREF" use="required"/>');
  xsd.Add('	  <!-- some information about the appearance an position of the element may optionally be specified -->');
  xsd.Add('	  <!-- NOTE: - these are not intended to allow complete graphical reproduction - just a way to retain general layout and colours -->');
  xsd.Add('   <xs:attribute name="width" type="xs:integer"/>  ');
  xsd.Add('   <xs:attribute name="height" type="xs:integer"/> ');
  xsd.Add('   <xs:attribute name="top" type="xs:integer"/> ');
  xsd.Add('   <xs:attribute name="bottom" type="xs:integer"/> ');
  xsd.Add('   <xs:attribute name="left" type="xs:integer"/> ');
  xsd.Add('   <xs:attribute name="right" type="xs:integer"/> ');
  xsd.Add('   <xs:attribute name="fillRGB" type="xs:integer"/> ');
  xsd.Add('   <xs:attribute name="textRGB" type="xs:integer"/> ');
  xsd.Add('   <xs:attribute name="borderRGB" type="xs:integer"/> ');
  xsd.Add('	  <!-- font-family is a comma separated list of the font family used (see XHTML specs on W3C for details) -->');
  xsd.Add('   <xs:attribute name="font-family" type="xs:string"/> ');
  xsd.Add('	  <!-- font-size is specified in points (pt = 1/12 pica) -->');
  xsd.Add('   <xs:attribute name="font-size" type="xs:decimal"/> ');
  xsd.Add(' </xs:attributeGroup>');
  xsd.Add('</xs:schema> ');
  xsd.SaveToFile(savedialog1.FileName);
  end;
  progressbar1.Position := 0;
  button2.Enabled := true;
  memo1.lines.AddStrings(errors);
end;

procedure TForm3.FormShow(Sender: TObject);
begin
  progressbar1.Position := 0;
end;

function tform3.createElementRef(elenName, diagName, indent, minOccurs : string) : tStringList;
var
  xml : tStringList;
  name : string;
begin
  xml := tStringList.Create;
  name := diagName + '_' + elenName;
  xml.Add(indent + '<xs:element name="' + name + '" minOccurs="' + minOccurs + '" maxOccurs="unbounded">');
  xml.Add(indent + '  <xs:complexType>');
  xml.Add(indent + '    <xs:attributeGroup ref="DiagElementAttributes"/>');
  xml.Add(indent + '  </xs:complexType>');
  xml.Add(indent + '</xs:element>');
  keyRefs.Add('		<xs:keyref name="' + name + 'Ref" refer="' + elenName + 'Key">');
  keyRefs.Add('			<xs:selector xpath=".//' + name + '"/>');
  keyRefs.Add('			<xs:field xpath="@ref"/>');
  keyRefs.Add('		</xs:keyref>');
  createElementRef := xml;
end;

{$R *.dfm}

end.
